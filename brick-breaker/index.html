<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Brick Breaker</title>

  <!-- ✅ 공용 스타일 -->
  <link rel="stylesheet" href="../shared/style.css">

  <!-- ✅ PWA 유지 -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0b1020">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
</head>
<body>
  <div id="root"></div>

  <script type="module">
    import {attachUI} from "../shared/ui.js";
    import {fitHiDPI, clamp, shaker, rint} from "../shared/utils.js";
    import {SFX} from "../shared/sfx.js";
    import {burst, updateAndDraw as drawParticles} from "../shared/particles.js";

    // 1) 공용 UI 세팅
    const ui = attachUI(document.getElementById("root"), {
      title:"Brick Breaker",
      instructions:"마우스/터치로 패들을 움직여 공을 튕겨 벽돌을 모두 제거하세요! (P=일시정지, R=재시작)"
    });
    const {canvas} = ui;
    const g = fitHiDPI(canvas, 1600, 900);
    const ctx = g.ctx;

    // 2) 상태
    let running=false, paused=false, score=0, lives=3;
    const particles=[];
    const paddle={x:g.w/2, y:g.h-40, w:200, h:18, target:g.w/2};
    const ball={x:g.w/2, y:g.h-80, vx:4, vy:-6, r:10, speed:8};
    let bricks=[], cols=12, rows=7, margin=12;

    function resetLevel(){
      bricks=[];
      const bw=(g.w - margin*2 - (cols-1)*8)/cols, bh=28;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          bricks.push({x:margin+c*(bw+8), y:100+r*(bh+6), w:bw, h:bh, hp:1+rint(0,1)});
        }
      }
    }
    function resetBall(){
      ball.x=g.w/2; ball.y=g.h-80; ball.vx=(Math.random()>.5?1:-1)*4; ball.vy=-6; ball.speed=8;
    }
    function restart(){
      score=0; ui.setScore(0,"brick-breaker");
      lives=3; rows=7; resetLevel(); resetBall();
      running=true; paused=false;
    }
    ui.wireHandlers(()=>{ if(!running) restart(); }, ()=>{ paused=!paused; }, ()=>restart());

    // 3) 입력(터치/마우스)
    canvas.addEventListener("pointermove", e=>{
      const r = canvas.getBoundingClientRect();
      const px = (e.clientX - r.left)/r.width * g.w;
      paddle.target = clamp(px, paddle.w/2, g.w - paddle.w/2);
    });

    // 4) 도우미
    const hitRect=(x,y,b)=> x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h;

    // 5) 루프
    let last=performance.now();
    function frame(t){
      requestAnimationFrame(frame);
      const dt=Math.min(32,t-last); last=t;

      // 배경
      ctx.clearRect(0,0,g.w,g.h);
      const grd=ctx.createLinearGradient(0,0,0,g.h); grd.addColorStop(0,"#0e1334"); grd.addColorStop(1,"#090b1f");
      ctx.fillStyle=grd; ctx.fillRect(0,0,g.w,g.h);

      if(!running){ drawDim("클릭 또는 Space로 시작"); return; }
      if(paused){ drawDim("일시정지 (P)"); return; }

      // 패들 이동(부드럽게)
      paddle.x += (paddle.target - paddle.x) * 0.25 * (dt/16);

      // 공 이동
      ball.x += ball.vx*(dt/16)*ball.speed;
      ball.y += ball.vy*(dt/16)*ball.speed;

      // 벽 반사
      if(ball.x<ball.r || ball.x>g.w-ball.r){ ball.vx*=-1; SFX.click(); }
      if(ball.y<ball.r){ ball.vy*=-1; SFX.click(); }

      // 바닥
      if(ball.y>g.h+40){
        lives--; shaker.add(10,200); SFX.boom(); resetBall();
        if(lives<0){ running=false; showOver(); return; }
      }

      // 패들 충돌
      const paddleBox={x:paddle.x-paddle.w/2,y:paddle.y-paddle.h/2,w:paddle.w,h:paddle.h};
      if(hitRect(ball.x,ball.y,paddleBox) && ball.vy>0){
        const t=(ball.x - paddle.x)/(paddle.w/2);
        ball.vx = t*6;
        ball.vy = -Math.sqrt(Math.max(4,36 - ball.vx*ball.vx));
        SFX.hit(); burst(particles, ball.x, paddle.y-10, "#80ffea", 10);
      }

      // 벽돌 충돌
      for(let i=bricks.length-1;i>=0;i--){
        const b=bricks[i];
        if(hitRect(ball.x,ball.y,b)){
          // 반사
          const cx = clamp(ball.x, b.x, b.x+b.w), cy = clamp(ball.y, b.y, b.y+b.h);
          if(Math.abs(ball.x - cx) > Math.abs(ball.y - cy)) ball.vx *= -1; else ball.vy *= -1;

          b.hp--;
          if(b.hp<=0){
            bricks.splice(i,1);
            score+=10; ui.setScore(score,"brick-breaker");
            SFX.score(); burst(particles, ball.x, ball.y, "#ffd166", 12);
          } else {
            SFX.hit();
          }
          shaker.add(4,120);
          break;
        }
      }

      // 난이도 곡선
      ball.speed = 8 + (1 - bricks.length/(cols*rows)) * 4;

      // 그리기(흔들림)
      ctx.save(); shaker.apply(ctx);

      // 패들
      ctx.fillStyle="#7cf1d1";
      ctx.fillRect(paddle.x-paddle.w/2, paddle.y-paddle.h/2, paddle.w, paddle.h);

      // 공
      ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();

      // 벽돌
      for(const b of bricks){
        ctx.fillStyle = b.hp>1 ? "#a2b1ff" : "#d0d7ff";
        ctx.fillRect(b.x, b.y, b.w, b.h);
      }

      // 파티클
      drawParticles(ctx, particles, dt);

      ctx.restore();

      // HUD 보조 텍스트
      ctx.fillStyle="#97a0d9"; ctx.font="18px system-ui";
      ctx.fillText(`Lives: ${Math.max(0,lives)}`, g.w-110, 30);

      // 클리어 → 다음 라운드
      if(bricks.length===0){ rows=Math.min(10, rows+1); resetLevel(); resetBall(); SFX.power(); }
    }
    requestAnimationFrame(frame);

    function drawDim(text){
      ctx.fillStyle="rgba(0,0,0,.25)"; ctx.fillRect(0,0,g.w,g.h);
      ctx.fillStyle="#e9ecff"; ctx.font="bold 42px system-ui"; ctx.textAlign="center";
      ctx.fillText(text, g.w/2, g.h/2);
    }

    function showOver(){
      ui.modal.style.display="grid";
      ui.modal.querySelector(".title").textContent="Game Over";
      ui.modal.querySelector(".subtitle").textContent=`점수 ${score}`;
    }

    // 초기화
    resetLevel();
  </script>

  <!-- ✅ 서비스워커(PWA) 유지 -->
  <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => navigator.serviceWorker.register("./service-worker.js"));
    }
  </script>
</body>
</html>
